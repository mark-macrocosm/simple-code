<?php
/**
 * Please fix the items marked with "@TODO" in this class
 *
 * Follow the https://www.php-fig.org/psr/psr-2/ coding style guide.
 *
 * One exception to PSR-2: opening braces MUST always be on the same line
 * for classes, methods, functions, and control structures
 */
class Singleton {
    
    /**
     * Provide a short description for constant blocks
     */
    const STRING_A = 'stringA';
    const STRING_B = 'stringB';
    const RESULT_A = 1;
    const RESULT_B = 2;
    const STRING_A_SHORT = 'A';
    const STRING_NON_A   = '^A';
    const STRING_NON_B   = '^B';
    const STRING_NON_C   = '^C';
    const STRING_ABC     = 'ABC';

    /**
     * Describe your methods
     * Prefix private/protected methods/properties with underscore
     * 
     * @var Singleton
     */
    private static $_instance = null;

    private function __construct() { // Space between () and {

    }

    /**
     * Always describe your methods
     * 
     * @return Singleton
     */
    public static function getInstance(): Singleton {
        // Although *correct*, using the "Elvis operator" leads to poor readability
        // It is generally best to also validate for type
        # return (self::$instance)
        #     ?: self::$instance = new static();
        
        if (null === self::$_instance) {
            self::$_instance = new self();
        }
        
        return self::$_instance;
    }


    /**
     * Display user name
     *
     * @param string $name User-provided name
     */
    public function userEcho(string $name): void {
        if (!is_string($name) || !strlen($name)) {
            throw new InvalidArgumentException('You need to provide alphabetical name.');
        }
        
        // count() first argument must be a countable or an array
        // never assume; $name could have Chinese characters
        # // I am validating the string count and also alpha-num check.
        # if (!count($name) || !ctype_alnum($name)) {
        #    throw new InvalidArgumentException('You need to provide alphabetical name.');
        # }

        // Removing unwanted tag (xss attack)
        $name = strip_tags($name);
        echo "The value of 'name' is '{$name}'";
    }

    /**
     * Query by user name
     *
     * @param string $name User-provided name
     */
    public function userQuery(string $name) {
        $conn = new mysqli('', '', '', '');

        $state = $conn->prepare('SELECT * FROM `test` WHERE `name` = ? LIMIT 1');

        $state->bind_param('s', $name);

        $state->execute();
    }

    /**
     * Output the contents of a file
     *
     * @param string $path User-provided file path
     */
    public function userFile(string $path) {
        // User paths are relative to this root
        $root = '/real/path/to/files';

        // The main point is to never allow users to perform directory traversal
        // Special characters like "." and ".." and direct root access should be forbidden
        if (!is_string($path) || !strlen($path)) {
            throw new Exception('No file path provided');
        }
        
        // Validate relative path, file name and extension
        if (!preg_match('%^(?:allowed_path_a|allowed_path_b)\/\w+\.(?:ext|png|jpe?g)$%i', $path)) {
            throw new Exception('Invalid file path');
        }

        // File not found
        if (!is_file("$root/$path")) {
            throw new Exception('File not found');
        }

        // No need to assume headers
        readfile("$root/$path");
        // No need to assume the script ends here
    }

    /**
     * Nested conditions
     */
    public function nestedConditions() {
        // Don't change return type; max. 1 return per function/method
        // Don't introduce new constants
        do {
            if (!$conditionA) {
                echo self::STRING_NON_A;
                break;
            }

            if (!$conditionB) {
                echo self::STRING_NON_B;
                break;
            }

            if (!$conditionC) {
                echo self::STRING_NON_C;
                break;
            }

            echo self::STRING_ABC;
        } while(false);
    }

    /**
     * Return statements
     *
     * @return boolean
     */
    public function returnStatements(): bool {
        // Avoid multiple returns        
        # if ($conditionA) {
        #     echo 'A';
        #     return true;
        # }
        # return false;

        # return ($conditionA) 
        // Print returns integer, not boolean
        #    ? print ('A') 
        #    : false;

        if ($conditionA) {
            echo self::STRING_A_SHORT;
        }

        // Implicit boolean conversion
        return !!$conditionA;
    }

    /**
     * Null coalescing
     */
    public function nullCoalescing(): string {
        return $_GET['name'] ?? $_POST['name'] ?? 'nobody';
    }

    /**
     * Method chaining
     */
    public function methodChained() :self {
        return $this;
    }

    /**
     * Immutables are hard to find
     */
    public function checkValue($value) {
        $result = null;

        // Make all the immutable values (int, string) in this class
        // easily replaceable
        switch ($value) {
            case self::STRING_A:
                $result = self::RESULT_A;
                break;

            case self::STRING_B:
                $result = self::RESULT_B;
                break;
        }

        return $result;
    }

    /**
     * Check a string is a 24 hour time
     *
     * @return boolean
     * @example "00:00:00", "23:59:59", "20:15"
     */
    public function regexTest(string $time24Hour): bool {
        // This RegEx matches the following invalid hour formats: 
        // 0
        // 0:1
        // 0:1:2
        # return preg_match('/^([0-1]?\d|2[0-3])(?::([0-5]?\d))?(?::([0-5]?\d))?$/', $time24Hour);
        
        // 0 left padding - so [01]\d instead of [01]?\d (02:00 instead of 2:00)
        // DRY - don't repeat yourself, the 00-59 minute/second block can appear once or twice
        // Don't user capturing blocks if you don't need them - (?:) instead of ()
        // preg_match returns 0,1 or false; expected return value is boolean
        return !!preg_match('/^(?:[01]\d|2[0-3])(?:\:[0-5]\d){1,2}$/', $time24Hour);
    }
}
